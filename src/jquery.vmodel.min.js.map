{"version":3,"sources":["jquery.vmodel.js"],"names":["$","version","storage","vmodel","api","this","obj_sort","obj","temp","i","each","key","val","sort","data","each_autoload","autoload_method_ary","name","type","local","msg_error","is_trigger_autoload","fnameary","e","console","log","get_autoload_funame","ary","atype","autoload","vname","res","end","end_p1","end_p2","param_match","returnary","get","pary","callback","id","setInterval","iscallback","storage_name","history","clearInterval","returnval","json","root","attr","parseJSON","info","p_2","p_3","chk_trigger_callback","allow","fun_struct","index","bool","display_attr","target_obj","d","Date","status","timestamp","parse","getMilliseconds","dej","push","encode","JSON","stringify","type_name","listen","type_listen","vmodel_get_callback","iid","fn","p_1","selector","remove_sign","str","substring","method_name","msg","define_autoload_struct","autoload_func","fun_name","ext_expend","extend","struct","isautoload","realobj","put_storage","main","result","jQuery"],"mappings":"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","file":"jquery.vmodel.min.js","sourcesContent":["(function ($) {\r\n\r\n    var version = \"1.5.4\";\r\n\r\n    // 實體化的存放倉儲，提供內部呼叫。\r\n    var storage = {}; \r\n\r\n    //整體使用\r\n    $.vmodel = {};\r\n\r\n\r\n    \r\n    // 內部全域的輔助方法\r\n    $.vmodel.api = new function (){\r\n\r\n        // 物件排序\r\n        this.obj_sort = function (obj){\r\n            var temp = [];\r\n            var i = 0;\r\n            \r\n            $.each(obj, function(key, val) {\r\n                temp[i++] = key;\r\n            });\r\n            \r\n            temp.sort();\r\n\r\n            var data = {};\r\n            $.each(temp, function (key, val){\r\n                data[val] = obj[val]\r\n            });\r\n\r\n            return data;\r\n        }\r\n\r\n        /**\r\n         * 批次呼叫可自動掛載的 function\r\n         * @param   autoload_method_ary     需要觸發的 function 名稱陣列\r\n         * @param   object                  也就是外部的實體化後的 $(selector).vmodel(\"匿名方法\")\r\n         */\r\n        this.each_autoload = function (autoload_method_ary, obj){\r\n\r\n            if (!autoload_method_ary) return false;\r\n\r\n            $.each(autoload_method_ary, function(key, name) {\r\n\r\n                if ($.type(obj[name]) != \"function\") {\r\n                    local.msg_error(name, \"不存在。\");\r\n                    return false;\r\n                }\r\n\r\n                // 觸發方法\r\n                obj[name]();\r\n            });\r\n\r\n            return true;\r\n        },\r\n\r\n        /**\r\n         * 若使用者有設定 autoload() 就會自動呼叫陣列中指定的方法\r\n         * @param obj      也就是外部的實體化後的 $(selector).vmodel(\"匿名方法\")\r\n         * @param fnameary 須要自動讀取的方法陣列\r\n         */\r\n        this.is_trigger_autoload = function (obj, fnameary){\r\n\r\n            try {\r\n                if (!fnameary) {\r\n                    throw \"須要指定方法名稱陣列\";\r\n                }\r\n                if ($.type(fnameary) != \"array\") {\r\n                    throw 'is_trigger_autoload() 代入的方法名稱必須要是陣列';\r\n                }\r\n                var result = $.vmodel.api.each_autoload(fnameary, obj);\r\n                return true;\r\n            }\r\n            catch(e) {\r\n                console.log(e);\r\n                return false;\r\n            }\r\n        }\r\n\r\n        // 從物件中取得 autoload 的方法陣列\r\n        this.get_autoload_funame = function (obj){\r\n            var ary   = [];\r\n            var atype = $.type(obj.autoload);\r\n\r\n            try{\r\n                // 取得 autoload 的陣列\r\n                if (atype == \"array\") {\r\n                    ary = obj.autoload;\r\n                } \r\n                else if (atype == \"function\") {\r\n                \r\n                    // 若有回傳陣列才替換\r\n                    res = obj.autoload();\r\n                    if ($.type(res) == \"array\") {\r\n                        ary = res;\r\n                    }\r\n                    else {\r\n                        throw obj.vname + \" 的 get_autoload_funame() 最終需要得到的型態應該是陣列。\";\r\n                    }\r\n                }\r\n\r\n                else {\r\n                    throw obj.vname + \" 的 autoload 須要是陣列或 function。\";\r\n                }\r\n\r\n                return ary;\r\n            }\r\n            catch(e) {\r\n                console.log(e);\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    // 呼叫版本名稱\r\n    $.vmodel.version = function (){\r\n        return version;\r\n    }\r\n\r\n    \r\n    /**\r\n     * 當指定多組的倉儲模組化完成後，要觸發的方法\r\n     *\r\n     * 注意，這需要每個模組都使用監聽完成視覺化，也就是 $.vmodel.get() 第三個參數\r\n     * \r\n     * @param   array | function     end_p1       監聽指定要完成的倉儲名稱陣列 | 回調方法\r\n     * @param   function             end_p2       回調方法, 並夾帶已經完成的倉儲物件\r\n     */\r\n    $.vmodel.end = function (end_p1, end_p2){\r\n\r\n        var local = this;\r\n\r\n        var issuccess = true;\r\n\r\n        /**\r\n         * 組合成一個陣列回傳參數\r\n         * @param   end_p1 \r\n         * @param   end_p2 \r\n         * @return  [要監聽的倉儲物件, callback()]\r\n         */\r\n        this.param_match = function(end_p1, end_p2) {\r\n            var returnary = [];\r\n\r\n            // 只有一個參數，就取得所有倉儲\r\n            if ($.type(end_p1) == \"function\") {\r\n                var storage = $.vmodel.get();\r\n                returnary = [storage, end_p1];\r\n            }\r\n            // 兩個參數，代表有指定要取得的倉儲\r\n            else {\r\n\r\n                var obj = {};\r\n                $.each(end_p1, function(key, name) {\r\n                    obj[name] = $.vmodel.get(name);\r\n                });\r\n                returnary = [obj, end_p2];\r\n            }\r\n\r\n            return returnary;\r\n        }\r\n\r\n        //命名方便使用\r\n        var pary     = local.param_match(end_p1, end_p2);\r\n        var storage  = pary[0];\r\n        var callback = pary[1];\r\n        end_p1 = end_p2 = null;\r\n\r\n        var id = setInterval(function (){\r\n\r\n            var iscallback = true;\r\n\r\n            // 檢查每個倉儲的視覺化狀態\r\n            $.each(storage, function (storage_name, obj){\r\n\r\n                var history = $.vmodel.history(obj.vname);\r\n\r\n                // false 代表還沒有完成，那就檢查下一個倉儲，且不觸發 callback\r\n                if (history == false) {\r\n                    iscallback = false;\r\n                    return true;\r\n                }\r\n\r\n                iscallback = true;\r\n            });\r\n\r\n\r\n            if (iscallback) {\r\n                callback(storage);\r\n                clearInterval(id);\r\n            }\r\n\r\n\r\n        }, 0);\r\n        \r\n    }\r\n\r\n\r\n    /**\r\n     * 取得視覺化屬性紀錄\r\n     * @param   name         倉儲名稱\r\n     * @return               有找到會返回視覺化的屬性物件；反之為 false\r\n     */\r\n    $.vmodel.history = function (name) {\r\n\r\n        var returnval = false;\r\n\r\n        // 找到綁在跟目錄的視覺化屬性\r\n        var storage   = $.vmodel.get(name);\r\n        var json      = storage.root.attr(\"data-vmodel-history\");\r\n        if (!json) return false;\r\n        var obj       = $.parseJSON(json);\r\n\r\n        // 搜尋\r\n        $.each(obj, function (key, info){\r\n            if (info.vname != name) return true;\r\n            returnval = info;\r\n            return false;\r\n        });\r\n\r\n        return returnval;\r\n    }\r\n\r\n\r\n    /**\r\n     * 取得倉儲\r\n     * @param   string            name    (選) 倉儲的存放名稱。當為空時，返回所有倉儲\r\n     * @param   bool              p_2     (選) 預設 false, 是否觸發倉儲 autoload\r\n     * @param   function | bool   p_3     (選) 是否啟用監聽並添加視覺化屬性。\r\n     *                                         注意，這是非同步。\r\n     *                                         function :   監聽直到完成模組後會觸發 callback，並夾帶了該倉儲。\r\n     *                                         true :       true 僅啟用監聽。\r\n     *                                         \r\n     * @return  object\r\n     */\r\n    $.vmodel.get = function (name, p_2, p_3){\r\n\r\n        var local = this;\r\n\r\n        // 判斷是否可以觸發回調 callback，\r\n        // 條件式當所有狀態都是 true\r\n        this.chk_trigger_callback = function (obj){\r\n\r\n            var allow = true;\r\n\r\n            $.each(obj.fun_struct, function(index, bool) {\r\n\r\n                // 如果遇到沒有初始化的，就終止檢查\r\n                if (bool == false) {\r\n                    allow = false;\r\n                    return false;\r\n                }\r\n\r\n            });\r\n\r\n            // 如果不允許就離開\r\n            // 若 autoload 中的方法都已經建構完成，那就可以呼叫回調 \r\n            return (allow == false) ? false : true;\r\n        }\r\n\r\n\r\n        // 視覺化屬性\r\n        this.display_attr = function (name, target_obj){\r\n\r\n            var d = new Date();\r\n\r\n            // 建立一個物件\r\n            var data = [{\r\n                vname: name, // 倉儲名稱\r\n                status: true, // 完成\r\n                timestamp : Date.parse(d) + \".\" + d.getMilliseconds(), //時間戳記\r\n            }];\r\n\r\n\r\n            // 視覺狀態是否存在, 若存在代表已經有倉儲也是綁定在這個元素，而且已完成。\r\n            // 這時候就合併已存在的，與新的。\r\n            var attr = target_obj.root.attr(\"data-vmodel-history\");\r\n            if (attr) {\r\n                var dej = $.parseJSON(attr);\r\n                dej.push(data[0]); // 務必使用 data[0] 剝除外面的陣列。\r\n                data = dej;\r\n            }\r\n\r\n\r\n            //視覺狀態\r\n            var encode = JSON.stringify(data);\r\n            target_obj.root.attr(\"data-vmodel-history\", encode); \r\n        }\r\n\r\n        // 僅做對應參數的輔助\r\n        this.param_match = function (name, p_2, p_3) {\r\n            var returnary = [];\r\n            var type_name = $.type(name);\r\n\r\n            // 返回所有倉儲\r\n            if (!name) {\r\n                returnary = [name, null, null];\r\n            }\r\n            // 指定一個倉儲名稱\r\n            else if (type_name == \"string\") {\r\n                returnary = [name, p_2, p_3];\r\n            }\r\n\r\n            return returnary;\r\n        }\r\n\r\n        // 重新命名\r\n        var pary     = local.param_match(name, p_2, p_3);\r\n        var name     = pary[0];\r\n        var autoload = pary[1];\r\n        var listen   = pary[2];\r\n        pary = p_2 = p_3 = null;\r\n\r\n\r\n        // 返回所有倉儲\r\n        if (!name) {\r\n            return $.vmodel.api.obj_sort(storage);\r\n        }\r\n\r\n        var target_obj = storage[name];\r\n        \r\n        // 呼叫的倉儲並不存在\r\n        if (!target_obj) {\r\n            console.log(\"呼叫的倉儲名稱 \"+ name +\" 不存在。\");\r\n            return false;\r\n        }\r\n\r\n        // 若參數2指定 bool 且為 true 的時候，會前往判斷，是否要觸發剛取得模組的 autoload()，若有就會優先觸發\r\n        if ($.type(autoload) == \"boolean\" && autoload == true) {\r\n\r\n            // 觸發 autoload()\r\n            var fnameary = $.vmodel.api.get_autoload_funame(target_obj);\r\n            var result   = $.vmodel.api.is_trigger_autoload(target_obj, fnameary);\r\n            // console.log(result); // for debugs\r\n\r\n            // 若有啟用監聽或回調函數\r\n            var type_listen = $.type(listen);\r\n            if (type_listen == \"function\" || (type_listen == \"boolean\" && listen == true)) {\r\n\r\n                // 若是回調\r\n                if (type_listen == \"function\") {\r\n                    // 必須先擴充到該模組底下，並勉多個倉儲會互相干擾\r\n                    target_obj.vmodel_get_callback = function (){\r\n                        listen(target_obj);\r\n                    }\r\n                }\r\n\r\n\r\n                //監聽\r\n                var iid = setInterval(function (){\r\n\r\n                    // 若全部狀態都完成\r\n                    if (local.chk_trigger_callback(target_obj) == true) {\r\n                        clearInterval(iid);\r\n\r\n                        // 視覺化添加屬性\r\n                        local.display_attr(name, target_obj);\r\n\r\n                        // 觸發回調\r\n                        if (type_listen == \"boolean\") return true;\r\n                        target_obj.vmodel_get_callback();\r\n                    }\r\n\r\n                }, 20);\r\n\r\n                return true\r\n            }\r\n        }\r\n\r\n        // 無論是否觸發使用者的 autoload(), 最後都會返回該實體化的物件\r\n        return storage[name];\r\n    }\r\n\r\n    /**\r\n     * 刪除指定的倉儲\r\n     * @param   name (選)倉儲名稱, 不指定會清空所有倉儲\r\n     */\r\n    $.vmodel.delete = function (name){\r\n        \r\n        if (!name && name != '') {\r\n            storage = {};\r\n        } else {\r\n            if (storage[name]) {\r\n                delete storage[name];\r\n            }\r\n        }\r\n        \r\n        return this;\r\n    }\r\n\r\n    /**\r\n     * 主要模式\r\n     * @param  mix       p_1 若是 string 倉儲命名；若是 function 代表準備在內部實體化的方法 \r\n     * @param  function  p_2 (選用) 若 p_1 為 string，就必須使用 p_2\r\n     * @return this      \r\n     */\r\n    $.fn.vmodel = function(p_1, p_2, p_3) {\r\n\r\n        // 內部\r\n        local   = this;\r\n        \r\n        // 選擇器\r\n        var selector = local.selector;\r\n\r\n        // 紀錄使用者要 autoload 的方法\r\n        // var autoload_func = [];\r\n\r\n        // 若前兩個字元是定位符號，就自動去除\r\n        this.remove_sign = function (str){\r\n            return (str.substring(0, 2) == \"--\") ? str.substring(2) : str;\r\n        }\r\n\r\n        /**\r\n         * 錯誤訊息\r\n         * @param   method_name 提示錯誤的 function 名稱\r\n         * @param   msg         錯誤訊息    \r\n         */\r\n        this.msg_error = function (method_name, msg){\r\n            console.log(\"錯誤：『\" + selector + \"』呼叫的 function 『\" + method_name + \"』：\" + msg);\r\n        }\r\n\r\n        \r\n\r\n        // 初始化使用者指定的 autoload 每個方法的建構狀態\r\n        this.define_autoload_struct = function (obj, autoload_func){\r\n            // 為每一個方法，都設定為 false，代表該方法還沒有建構完成\r\n            $.each(autoload_func, function(index, fun_name) {\r\n                obj.fun_struct[fun_name] = false;\r\n            });\r\n        }\r\n\r\n        // 外部擴充方法\r\n        this.ext_expend = function (obj, name){\r\n            var vname = (name != null) ? name : null;\r\n            $.extend(obj, {\r\n\r\n                vname : vname,\r\n\r\n                // 根選擇器\r\n                selector : selector,        \r\n\r\n                // 根選擇器物件    \r\n                root : $(local),\r\n\r\n                // 在倉儲中建立一個 fun_struct 物件\r\n                // 用來存放每個 autoload 的方法名稱，\r\n                // 並預設建構狀態為 false, 等到使用者手動為 true，\r\n                // 才代表這個方法完成建構。\r\n                fun_struct : {},\r\n\r\n                /**\r\n                 * 提供外部指定倉儲的模組化狀態。\r\n                 * @param   name   autoload 指定的陣列倉儲名稱。可以是單一名稱會陣列。\r\n                 *                 如 \"say\" 或 ['say', 'hello']\r\n                 * @param   bool   (選) true:(預設)完成 | false : 未完成\r\n                 */\r\n                struct : function (name, status) {\r\n\r\n                    if ($.type(status) != \"boolean\" && !status) {\r\n                        status = true;\r\n                    }\r\n\r\n\r\n                    // 若使用字串\r\n                    if ($.type(name) == \"string\") {\r\n                        if ($.type(obj.fun_struct[name]) != \"boolean\") {\r\n                            console.log('找不到名稱為 ' + name + '的建構狀態');\r\n                            return false;\r\n                        }\r\n\r\n                        // 設定指定狀態\r\n                        obj.fun_struct[name] = status;\r\n                    }\r\n\r\n                    // 若是陣列如 ['say', 'hello']\r\n                    else if ($.type(name) == \"array\"){\r\n                        $.each(name, function (key, val){\r\n                            obj.fun_struct[val] = status;\r\n                        })\r\n                    }\r\n                    else {\r\n                        console.log('建構名稱須要指定');\r\n                        return false;\r\n                    }\r\n\r\n                    return true;\r\n                }\r\n            });\r\n            return obj;\r\n        }\r\n\r\n        /**\r\n         * 組合成一個陣列回傳參數\r\n         * @return  [倉儲名稱, 是否啟用 autoload, 實體化物件]\r\n         */\r\n        this.param_match = function (p_1, p_2, p_3){\r\n            var name       = null;\r\n            var isautoload = null;\r\n            var realobj    = null;\r\n\r\n            // 若第一個參數為倉儲命名\r\n            if ($.type(p_1) == \"string\") {\r\n\r\n                // 去除定位符號\r\n                name = local.remove_sign(p_1);\r\n\r\n                // 若第二個參數為布林值\r\n                if ($.type(p_2) == \"boolean\") {\r\n                    isautoload = p_2;\r\n                    realobj    = new p_3();\r\n                }\r\n\r\n                // 若不是布林值，代表應該就是匿名方法, 我們將他實體化\r\n                else {\r\n                    realobj    = new p_2();\r\n                }\r\n\r\n            }\r\n            // 這是使用者定義的 function, 我們將他實體化\r\n            else {\r\n                realobj      = new p_1();\r\n            }\r\n\r\n            return [name, isautoload, realobj];\r\n        }\r\n\r\n        // 放入倉儲\r\n        this.put_storage = function (name, realobj){\r\n\r\n            if (name != null) {\r\n\r\n                // 檢查是否已存在\r\n                if (!storage[name]) {\r\n                    storage[name] = realobj;\r\n                }\r\n                else {\r\n                    console.log(\"倉儲名稱『\" + name + \"』重複。\");\r\n                    return false;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.main = function (p_1, p_2, p_3){\r\n            \r\n\r\n            // 參數對應\r\n            var pary       = local.param_match(p_1, p_2, p_3);\r\n            var name       = pary[0]; \r\n            var isautoload = pary[1]; \r\n            var realobj    = pary[2]; \r\n            p_1 = p_2 = p_3 = null;\r\n\r\n            // 擴充，外部不可使用這些關鍵字\r\n            var realobj    = local.ext_expend(realobj, name);\r\n            \r\n            // 取得 autoload 的方法陣列\r\n            var fnameary = $.vmodel.api.get_autoload_funame(realobj);\r\n\r\n            // 先定義建構狀態\r\n            local.define_autoload_struct(realobj, fnameary);\r\n\r\n            // 放入倉儲\r\n            local.put_storage(name, realobj);\r\n\r\n            // 最後才觸發 autoload 。\r\n            // 這是因為當前的物件，才能被任何倉儲裡的方法取得。\r\n            // 例如自己呼叫自己。\r\n            if (isautoload === true) {\r\n                var result = $.vmodel.api.is_trigger_autoload(realobj, fnameary);\r\n                if (result === false) local.msg_error(\"is_trigger_autoload\", \"發生錯誤\");\r\n            }\r\n            \r\n            return this;\r\n        }\r\n\r\n        // 返回實體化的，可供外部調用\r\n        return local.main(p_1, p_2, p_3);\r\n    }\r\n\r\n\r\n}( jQuery ));"]}